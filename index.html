<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Shooting Sim</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        .joystick {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.3); border: 2px solid white;
            touch-action: none;
        }
        #moveJoystick { bottom: 100px; left: 10px; }
        #lookJoystick { bottom: 100px; right: 10px; }
        #fireButton {
            position: absolute; width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255, 0, 0, 0.5); border: 2px solid red;
            bottom: 10px; right: 50%; transform: translateX(50%);
            touch-action: none;
        }
        .knob {
            width: 30px; height: 30px; border-radius: 50%; background: white;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        #hud {
            position: absolute; top: 10px; left: 10px; color: white;
            text-shadow: 1px 1px 2px black; font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="moveJoystick" class="joystick"><div class="knob"></div></div>
    <div id="lookJoystick" class="joystick"><div class="knob"></div></div>
    <div id="fireButton"></div>
    <div id="hud"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(20, 30, 20);
        scene.add(directionalLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Walls
        const wallGeometry = new THREE.BoxGeometry(200, 8, 1);
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
        const walls = [
            { pos: [0, 4, -100], rot: [0, 0, 0] },
            { pos: [0, 4, 100], rot: [0, 0, 0] },
            { pos: [-100, 4, 0], rot: [0, Math.PI / 2, 0] },
            { pos: [100, 4, 0], rot: [0, Math.PI / 2, 0] }
        ];
        walls.forEach(w => {
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(...w.pos);
            wall.rotation.set(...w.rot);
            scene.add(wall);
        });

        // Targets
        const targetGeometry = new THREE.SphereGeometry(1, 16, 16);
        const targetMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const targets = [];
        function spawnTarget() {
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.position.set(Math.random() * 180 - 90, 1, Math.random() * 180 - 90);
            scene.add(target);
            targets.push(target);
        }
        for (let i = 0; i < 10; i++) spawnTarget();

        // Player setup
        camera.position.y = 2;
        const velocity = new THREE.Vector3();
        const moveSpeed = 0.2;

        // Game logic
        let score = 0;
        let timeLeft = 60;
        let gameOver = false;
        const hud = document.getElementById('hud');

        // Touch controls
        const moveJoystick = document.getElementById('moveJoystick');
        const moveKnob = moveJoystick.querySelector('.knob');
        const lookJoystick = document.getElementById('lookJoystick');
        const lookKnob = lookJoystick.querySelector('.knob');
        const fireButton = document.getElementById('fireButton');
        let moveTouchId = null, lookTouchId = null, fireTouchId = null;
        let moveVector = new THREE.Vector2(), lookVector = new THREE.Vector2();

        function updateJoystick(touch, joystick, knob, vector) {
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = Math.min(Math.max(touch.clientX - centerX, -40), 40);
            const dy = Math.min(Math.max(touch.clientY - centerY, -40), 40);
            knob.style.left = `calc(50% + ${dx}px)`;
            knob.style.top = `calc(50% + ${dy}px)`;
            vector.set(dx / 40, -dy / 40);
        }

        document.addEventListener('touchstart', (e) => {
            if (gameOver) return;
            for (let touch of e.changedTouches) {
                if (!moveTouchId && moveJoystick.contains(touch.target)) {
                    moveTouchId = touch.identifier;
                    updateJoystick(touch, moveJoystick, moveKnob, moveVector);
                } else if (!lookTouchId && lookJoystick.contains(touch.target)) {
                    lookTouchId = touch.identifier;
                    updateJoystick(touch, lookJoystick, lookKnob, lookVector);
                } else if (!fireTouchId && fireButton.contains(touch.target)) {
                    fireTouchId = touch.identifier;
                    shoot();
                }
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (gameOver) return;
            for (let touch of e.touches) {
                if (touch.identifier === moveTouchId) {
                    updateJoystick(touch, moveJoystick, moveKnob, moveVector);
                } else if (touch.identifier === lookTouchId) {
                    updateJoystick(touch, lookJoystick, lookKnob, lookVector);
                }
            }
        });

        document.addEventListener('touchend', (e) => {
            if (gameOver) return;
            for (let touch of e.changedTouches) {
                if (touch.identifier === moveTouchId) {
                    moveTouchId = null;
                    moveKnob.style.left = '50%';
                    moveKnob.style.top = '50%';
                    moveVector.set(0, 0);
                } else if (touch.identifier === lookTouchId) {
                    lookTouchId = null;
                    lookKnob.style.left = '50%';
                    lookKnob.style.top = '50%';
                    lookVector.set(0, 0);
                } else if (touch.identifier === fireTouchId) {
                    fireTouchId = null;
                }
            }
        });

        // Shooting logic
        function shoot() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const hitTarget = intersects[0].object;
                scene.remove(hitTarget);
                targets.splice(targets.indexOf(hitTarget), 1);
                score += 1;
                setTimeout(spawnTarget, 500); // Respawn after 0.5s
            }
        }

        // Keyboard controls
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': shoot(); break;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (gameOver) return;
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // Mouse controls
        let isMouseLocked = false;
        document.addEventListener('click', () => {
            if (gameOver) return;
            if (!isMouseLocked) {
                renderer.domElement.requestPointerLock();
                isMouseLocked = true;
            }
        });
        document.addEventListener('mousemove', (e) => {
            if (gameOver) return;
            if (isMouseLocked) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - e.movementY * 0.002));
            }
        });
        document.addEventListener('mousedown', (e) => {
            if (gameOver) return;
            if (isMouseLocked && e.button === 0) shoot();
        });

        // Animation loop
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now();
            const delta = Math.min((currentTime - lastTime) / 1000, 0.1); // Cap delta for smoothness
            lastTime = currentTime;

            if (!gameOver) {
                // Movement
                velocity.x -= velocity.x * 10 * delta; // Smooth friction
                velocity.z -= velocity.z * 10 * delta;
                const moveX = moveVector.x || (moveRight ? 1 : moveLeft ? -1 : 0);
                const moveZ = moveVector.y || (moveForward ? 1 : moveBackward ? -1 : 0);
                velocity.x += moveX * moveSpeed;
                velocity.z += moveZ * moveSpeed;

                const newX = camera.position.x + velocity.x;
                const newZ = camera.position.z + velocity.z;
                if (newX > -98 && newX < 98) camera.position.x = newX;
                if (newZ > -98 && newZ < 98) camera.position.z = newZ;
                camera.position.y = 2;

                // Look
                camera.rotation.y -= lookVector.x * 0.05;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - lookVector.y * 0.05));

                // Game logic
                timeLeft -= delta;
                if (timeLeft <= 0) {
                    timeLeft = 0;
                    gameOver = true;
                    hud.innerHTML = `Game Over! Final Score: ${score}`;
                } else {
                    hud.innerHTML = `Score: ${score} | Time: ${Math.round(timeLeft)}s`;
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
